"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Protocol definition file for GTFS Realtime.

GTFS Realtime lets transit agencies provide consumers with realtime
information about disruptions to their service (stations closed, lines not
operating, important delays etc), location of their vehicles and expected
arrival times.

This protocol is published at:
https://github.com/google/transit/tree/master/gtfs-realtime
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class FeedMessage(google.protobuf.message.Message):
    """The contents of a feed message.
    A feed is a continuous stream of feed messages. Each message in the stream is
    obtained as a response to an appropriate HTTP GET request.
    A realtime feed is always defined with relation to an existing GTFS feed.
    All the entity ids are resolved with respect to the GTFS feed.
    Note that "required" and "optional" as stated in this file refer to Protocol
    Buffer cardinality, not semantic cardinality.  See reference.md at
    https://github.com/google/transit/tree/master/gtfs-realtime for field
    semantic cardinality.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    HEADER_FIELD_NUMBER: builtins.int
    ENTITY_FIELD_NUMBER: builtins.int
    @property
    def header(self) -> global___FeedHeader:
        """Metadata about this feed and feed message."""
    @property
    def entity(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FeedEntity]:
        """Contents of the feed."""
    def __init__(
        self,
        *,
        header: global___FeedHeader | None = ...,
        entity: collections.abc.Iterable[global___FeedEntity] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["header", b"header"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["entity", b"entity", "header", b"header"]) -> None: ...

global___FeedMessage = FeedMessage

@typing_extensions.final
class FeedHeader(google.protobuf.message.Message):
    """Metadata about a feed, included in feed messages."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Incrementality:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _IncrementalityEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[FeedHeader._Incrementality.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        FULL_DATASET: FeedHeader._Incrementality.ValueType  # 0
        DIFFERENTIAL: FeedHeader._Incrementality.ValueType  # 1

    class Incrementality(_Incrementality, metaclass=_IncrementalityEnumTypeWrapper):
        """Determines whether the current fetch is incremental.  Currently,
        DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
        that use this mode.  There are discussions on the GTFS Realtime mailing
        list around fully specifying the behavior of DIFFERENTIAL mode and the
        documentation will be updated when those discussions are finalized.
        """

    FULL_DATASET: FeedHeader.Incrementality.ValueType  # 0
    DIFFERENTIAL: FeedHeader.Incrementality.ValueType  # 1

    GTFS_REALTIME_VERSION_FIELD_NUMBER: builtins.int
    INCREMENTALITY_FIELD_NUMBER: builtins.int
    TIMESTAMP_FIELD_NUMBER: builtins.int
    gtfs_realtime_version: builtins.str
    """Version of the feed specification.
    The current version is 2.0.  Valid versions are "2.0", "1.0".
    """
    incrementality: global___FeedHeader.Incrementality.ValueType
    timestamp: builtins.int
    """This timestamp identifies the moment when the content of this feed has been
    created (in server time). In POSIX time (i.e., number of seconds since
    January 1st 1970 00:00:00 UTC).
    """
    def __init__(
        self,
        *,
        gtfs_realtime_version: builtins.str | None = ...,
        incrementality: global___FeedHeader.Incrementality.ValueType | None = ...,
        timestamp: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["gtfs_realtime_version", b"gtfs_realtime_version", "incrementality", b"incrementality", "timestamp", b"timestamp"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["gtfs_realtime_version", b"gtfs_realtime_version", "incrementality", b"incrementality", "timestamp", b"timestamp"]) -> None: ...

global___FeedHeader = FeedHeader

@typing_extensions.final
class FeedEntity(google.protobuf.message.Message):
    """A definition (or update) of an entity in the transit feed."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    IS_DELETED_FIELD_NUMBER: builtins.int
    TRIP_UPDATE_FIELD_NUMBER: builtins.int
    VEHICLE_FIELD_NUMBER: builtins.int
    ALERT_FIELD_NUMBER: builtins.int
    SHAPE_FIELD_NUMBER: builtins.int
    id: builtins.str
    """The ids are used only to provide incrementality support. The id should be
    unique within a FeedMessage. Consequent FeedMessages may contain
    FeedEntities with the same id. In case of a DIFFERENTIAL update the new
    FeedEntity with some id will replace the old FeedEntity with the same id
    (or delete it - see is_deleted below).
    The actual GTFS entities (e.g. stations, routes, trips) referenced by the
    feed must be specified by explicit selectors (see EntitySelector below for
    more info).
    """
    is_deleted: builtins.bool
    """Whether this entity is to be deleted. Relevant only for incremental
    fetches.
    """
    @property
    def trip_update(self) -> global___TripUpdate:
        """Data about the entity itself. Exactly one of the following fields must be
        present (unless the entity is being deleted).
        """
    @property
    def vehicle(self) -> global___VehiclePosition: ...
    @property
    def alert(self) -> global___Alert: ...
    @property
    def shape(self) -> global___Shape:
        """NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future."""
    def __init__(
        self,
        *,
        id: builtins.str | None = ...,
        is_deleted: builtins.bool | None = ...,
        trip_update: global___TripUpdate | None = ...,
        vehicle: global___VehiclePosition | None = ...,
        alert: global___Alert | None = ...,
        shape: global___Shape | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["alert", b"alert", "id", b"id", "is_deleted", b"is_deleted", "shape", b"shape", "trip_update", b"trip_update", "vehicle", b"vehicle"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["alert", b"alert", "id", b"id", "is_deleted", b"is_deleted", "shape", b"shape", "trip_update", b"trip_update", "vehicle", b"vehicle"]) -> None: ...

global___FeedEntity = FeedEntity

@typing_extensions.final
class TripUpdate(google.protobuf.message.Message):
    """
    Entities used in the feed.

    Realtime update of the progress of a vehicle along a trip.
    Depending on the value of ScheduleRelationship, a TripUpdate can specify:
    - A trip that proceeds along the schedule.
    - A trip that proceeds along a route but has no fixed schedule.
    - A trip that have been added or removed with regard to schedule.

    The updates can be for future, predicted arrival/departure events, or for
    past events that already occurred.
    Normally, updates should get more precise and more certain (see
    uncertainty below) as the events gets closer to current time.
    Even if that is not possible, the information for past events should be
    precise and certain. In particular, if an update points to time in the past
    but its update's uncertainty is not 0, the client should conclude that the
    update is a (wrong) prediction and that the trip has not completed yet.

    Note that the update can describe a trip that is already completed.
    To this end, it is enough to provide an update for the last stop of the trip.
    If the time of that is in the past, the client will conclude from that that
    the whole trip is in the past (it is possible, although inconsequential, to
    also provide updates for preceding stops).
    This option is most relevant for a trip that has completed ahead of schedule,
    but according to the schedule, the trip is still proceeding at the current
    time. Removing the updates for this trip could make the client assume
    that the trip is still proceeding.
    Note that the feed provider is allowed, but not required, to purge past
    updates - this is one case where this would be practically useful.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class StopTimeEvent(google.protobuf.message.Message):
        """Timing information for a single predicted event (either arrival or
        departure).
        Timing consists of delay and/or estimated time, and uncertainty.
        - delay should be used when the prediction is given relative to some
          existing schedule in GTFS.
        - time should be given whether there is a predicted schedule or not. If
          both time and delay are specified, time will take precedence
          (although normally, time, if given for a scheduled trip, should be
          equal to scheduled time in GTFS + delay).

        Uncertainty applies equally to both time and delay.
        The uncertainty roughly specifies the expected error in true delay (but
        note, we don't yet define its precise statistical meaning). It's possible
        for the uncertainty to be 0, for example for trains that are driven under
        computer timing control.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        DELAY_FIELD_NUMBER: builtins.int
        TIME_FIELD_NUMBER: builtins.int
        UNCERTAINTY_FIELD_NUMBER: builtins.int
        delay: builtins.int
        """Delay (in seconds) can be positive (meaning that the vehicle is late) or
        negative (meaning that the vehicle is ahead of schedule). Delay of 0
        means that the vehicle is exactly on time.
        """
        time: builtins.int
        """Event as absolute time.
        In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
        UTC).
        """
        uncertainty: builtins.int
        """If uncertainty is omitted, it is interpreted as unknown.
        If the prediction is unknown or too uncertain, the delay (or time) field
        should be empty. In such case, the uncertainty field is ignored.
        To specify a completely certain prediction, set its uncertainty to 0.
        """
        def __init__(
            self,
            *,
            delay: builtins.int | None = ...,
            time: builtins.int | None = ...,
            uncertainty: builtins.int | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["delay", b"delay", "time", b"time", "uncertainty", b"uncertainty"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["delay", b"delay", "time", b"time", "uncertainty", b"uncertainty"]) -> None: ...

    @typing_extensions.final
    class StopTimeUpdate(google.protobuf.message.Message):
        """Realtime update for arrival and/or departure events for a given stop on a
        trip. Updates can be supplied for both past and future events.
        The producer is allowed, although not required, to drop past events.
        The update is linked to a specific stop either through stop_sequence or
        stop_id, so one of the fields below must necessarily be set.
        See the documentation in TripDescriptor for more information.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _ScheduleRelationship:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _ScheduleRelationshipEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[TripUpdate.StopTimeUpdate._ScheduleRelationship.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            SCHEDULED: TripUpdate.StopTimeUpdate._ScheduleRelationship.ValueType  # 0
            """The vehicle is proceeding in accordance with its static schedule of
            stops, although not necessarily according to the times of the schedule.
            At least one of arrival and departure must be provided. If the schedule
            for this stop contains both arrival and departure times then so must
            this update. Frequency-based trips (GTFS frequencies.txt with exact_times = 0)
            should not have a SCHEDULED value and should use UNSCHEDULED instead.
            """
            SKIPPED: TripUpdate.StopTimeUpdate._ScheduleRelationship.ValueType  # 1
            """The stop is skipped, i.e., the vehicle will not stop at this stop.
            Arrival and departure are optional.
            """
            NO_DATA: TripUpdate.StopTimeUpdate._ScheduleRelationship.ValueType  # 2
            """No StopTimeEvents are given for this stop.
            The main intention for this value is to give time predictions only for
            part of a trip, i.e., if the last update for a trip has a NO_DATA
            specifier, then StopTimeEvents for the rest of the stops in the trip
            are considered to be unspecified as well.
            Neither arrival nor departure should be supplied.
            """
            UNSCHEDULED: TripUpdate.StopTimeUpdate._ScheduleRelationship.ValueType  # 3
            """The vehicle is operating a trip defined in GTFS frequencies.txt with exact_times = 0.
            This value should not be used for trips that are not defined in GTFS frequencies.txt,
            or trips in GTFS frequencies.txt with exact_times = 1. Trips containing StopTimeUpdates
            with ScheduleRelationship=UNSCHEDULED must also set TripDescriptor.ScheduleRelationship=UNSCHEDULED.
            NOTE: This field is still experimental, and subject to change. It may be
            formally adopted in the future.
            """

        class ScheduleRelationship(_ScheduleRelationship, metaclass=_ScheduleRelationshipEnumTypeWrapper):
            """The relation between the StopTimeEvents and the static schedule."""

        SCHEDULED: TripUpdate.StopTimeUpdate.ScheduleRelationship.ValueType  # 0
        """The vehicle is proceeding in accordance with its static schedule of
        stops, although not necessarily according to the times of the schedule.
        At least one of arrival and departure must be provided. If the schedule
        for this stop contains both arrival and departure times then so must
        this update. Frequency-based trips (GTFS frequencies.txt with exact_times = 0)
        should not have a SCHEDULED value and should use UNSCHEDULED instead.
        """
        SKIPPED: TripUpdate.StopTimeUpdate.ScheduleRelationship.ValueType  # 1
        """The stop is skipped, i.e., the vehicle will not stop at this stop.
        Arrival and departure are optional.
        """
        NO_DATA: TripUpdate.StopTimeUpdate.ScheduleRelationship.ValueType  # 2
        """No StopTimeEvents are given for this stop.
        The main intention for this value is to give time predictions only for
        part of a trip, i.e., if the last update for a trip has a NO_DATA
        specifier, then StopTimeEvents for the rest of the stops in the trip
        are considered to be unspecified as well.
        Neither arrival nor departure should be supplied.
        """
        UNSCHEDULED: TripUpdate.StopTimeUpdate.ScheduleRelationship.ValueType  # 3
        """The vehicle is operating a trip defined in GTFS frequencies.txt with exact_times = 0.
        This value should not be used for trips that are not defined in GTFS frequencies.txt,
        or trips in GTFS frequencies.txt with exact_times = 1. Trips containing StopTimeUpdates
        with ScheduleRelationship=UNSCHEDULED must also set TripDescriptor.ScheduleRelationship=UNSCHEDULED.
        NOTE: This field is still experimental, and subject to change. It may be
        formally adopted in the future.
        """

        @typing_extensions.final
        class StopTimeProperties(google.protobuf.message.Message):
            """Provides the updated values for the stop time.
            NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
            """

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            ASSIGNED_STOP_ID_FIELD_NUMBER: builtins.int
            assigned_stop_id: builtins.str
            """Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
            The new assigned_stop_id should not result in a significantly different trip experience for the end user than
            the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
            "unusual change" if the new stop was presented within an app without any additional context.
            For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
            same station as the stop originally defined in GTFS stop_times.txt.
            To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
            StopTimeUpdate.schedule_relationship = NO_DATA.
            If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
            `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
            Platform assignments should be reflected in other GTFS-realtime fields as well
            (e.g., `VehiclePosition.stop_id`).
            NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
            """
            def __init__(
                self,
                *,
                assigned_stop_id: builtins.str | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["assigned_stop_id", b"assigned_stop_id"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["assigned_stop_id", b"assigned_stop_id"]) -> None: ...

        STOP_SEQUENCE_FIELD_NUMBER: builtins.int
        STOP_ID_FIELD_NUMBER: builtins.int
        ARRIVAL_FIELD_NUMBER: builtins.int
        DEPARTURE_FIELD_NUMBER: builtins.int
        DEPARTURE_OCCUPANCY_STATUS_FIELD_NUMBER: builtins.int
        SCHEDULE_RELATIONSHIP_FIELD_NUMBER: builtins.int
        STOP_TIME_PROPERTIES_FIELD_NUMBER: builtins.int
        stop_sequence: builtins.int
        """Must be the same as in stop_times.txt in the corresponding GTFS feed."""
        stop_id: builtins.str
        """Must be the same as in stops.txt in the corresponding GTFS feed."""
        @property
        def arrival(self) -> global___TripUpdate.StopTimeEvent: ...
        @property
        def departure(self) -> global___TripUpdate.StopTimeEvent: ...
        departure_occupancy_status: global___VehiclePosition.OccupancyStatus.ValueType
        """Expected occupancy after departure from the given stop.
        Should be provided only for future stops.
        In order to provide departure_occupancy_status without either arrival or
        departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA.
        """
        schedule_relationship: global___TripUpdate.StopTimeUpdate.ScheduleRelationship.ValueType
        @property
        def stop_time_properties(self) -> global___TripUpdate.StopTimeUpdate.StopTimeProperties:
            """Realtime updates for certain properties defined within GTFS stop_times.txt
            NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
            """
        def __init__(
            self,
            *,
            stop_sequence: builtins.int | None = ...,
            stop_id: builtins.str | None = ...,
            arrival: global___TripUpdate.StopTimeEvent | None = ...,
            departure: global___TripUpdate.StopTimeEvent | None = ...,
            departure_occupancy_status: global___VehiclePosition.OccupancyStatus.ValueType | None = ...,
            schedule_relationship: global___TripUpdate.StopTimeUpdate.ScheduleRelationship.ValueType | None = ...,
            stop_time_properties: global___TripUpdate.StopTimeUpdate.StopTimeProperties | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["arrival", b"arrival", "departure", b"departure", "departure_occupancy_status", b"departure_occupancy_status", "schedule_relationship", b"schedule_relationship", "stop_id", b"stop_id", "stop_sequence", b"stop_sequence", "stop_time_properties", b"stop_time_properties"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["arrival", b"arrival", "departure", b"departure", "departure_occupancy_status", b"departure_occupancy_status", "schedule_relationship", b"schedule_relationship", "stop_id", b"stop_id", "stop_sequence", b"stop_sequence", "stop_time_properties", b"stop_time_properties"]) -> None: ...

    @typing_extensions.final
    class TripProperties(google.protobuf.message.Message):
        """Defines updated properties of the trip, such as a new shape_id when there is a detour. Or defines the
        trip_id, start_date, and start_time of a DUPLICATED trip. 
        NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TRIP_ID_FIELD_NUMBER: builtins.int
        START_DATE_FIELD_NUMBER: builtins.int
        START_TIME_FIELD_NUMBER: builtins.int
        SHAPE_ID_FIELD_NUMBER: builtins.int
        trip_id: builtins.str
        """Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
        but will start at a different service date and/or time (defined using the TripProperties.start_date and
        TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
        than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
        be populated and will be ignored by consumers.
        NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        """
        start_date: builtins.str
        """Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
        schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
        NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        """
        start_time: builtins.str
        """Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
        in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
        between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
        departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
        of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
        delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
        departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
        prediction time values do not have any offset applied to them and indicate the predicted time as provided.
        For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
        is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
        populated and will be ignored by consumers.
        NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        """
        shape_id: builtins.str
        """Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in
        (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing
        paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS
        nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt
        or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as
        (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should
        be marked as schedule_relationship=SKIPPED.
        NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        """
        def __init__(
            self,
            *,
            trip_id: builtins.str | None = ...,
            start_date: builtins.str | None = ...,
            start_time: builtins.str | None = ...,
            shape_id: builtins.str | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["shape_id", b"shape_id", "start_date", b"start_date", "start_time", b"start_time", "trip_id", b"trip_id"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["shape_id", b"shape_id", "start_date", b"start_date", "start_time", b"start_time", "trip_id", b"trip_id"]) -> None: ...

    TRIP_FIELD_NUMBER: builtins.int
    VEHICLE_FIELD_NUMBER: builtins.int
    STOP_TIME_UPDATE_FIELD_NUMBER: builtins.int
    TIMESTAMP_FIELD_NUMBER: builtins.int
    DELAY_FIELD_NUMBER: builtins.int
    TRIP_PROPERTIES_FIELD_NUMBER: builtins.int
    @property
    def trip(self) -> global___TripDescriptor:
        """The Trip that this message applies to. There can be at most one
        TripUpdate entity for each actual trip instance.
        If there is none, that means there is no prediction information available.
        It does *not* mean that the trip is progressing according to schedule.
        """
    @property
    def vehicle(self) -> global___VehicleDescriptor:
        """Additional information on the vehicle that is serving this trip."""
    @property
    def stop_time_update(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TripUpdate.StopTimeUpdate]:
        """Updates to StopTimes for the trip (both future, i.e., predictions, and in
        some cases, past ones, i.e., those that already happened).
        The updates must be sorted by stop_sequence, and apply for all the
        following stops of the trip up to the next specified one.

        Example 1:
        For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
        delay of 0 for stop_sequence of the current stop means that the trip is
        exactly on time.

        Example 2:
        For the same trip instance, 3 StopTimeUpdates are provided:
        - delay of 5 min for stop_sequence 3
        - delay of 1 min for stop_sequence 8
        - delay of unspecified duration for stop_sequence 10
        This will be interpreted as:
        - stop_sequences 3,4,5,6,7 have delay of 5 min.
        - stop_sequences 8,9 have delay of 1 min.
        - stop_sequences 10,... have unknown delay.
        """
    timestamp: builtins.int
    """The most recent moment at which the vehicle's real-time progress was measured
    to estimate StopTimes in the future. When StopTimes in the past are provided,
    arrival/departure times may be earlier than this value. In POSIX
    time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
    """
    delay: builtins.int
    """The current schedule deviation for the trip.  Delay should only be
    specified when the prediction is given relative to some existing schedule
    in GTFS.

    Delay (in seconds) can be positive (meaning that the vehicle is late) or
    negative (meaning that the vehicle is ahead of schedule). Delay of 0
    means that the vehicle is exactly on time.

    Delay information in StopTimeUpdates take precedent of trip-level delay
    information, such that trip-level delay is only propagated until the next
    stop along the trip with a StopTimeUpdate delay value specified.

    Feed providers are strongly encouraged to provide a TripUpdate.timestamp
    value indicating when the delay value was last updated, in order to
    evaluate the freshness of the data.

    NOTE: This field is still experimental, and subject to change. It may be
    formally adopted in the future.
    """
    @property
    def trip_properties(self) -> global___TripUpdate.TripProperties: ...
    def __init__(
        self,
        *,
        trip: global___TripDescriptor | None = ...,
        vehicle: global___VehicleDescriptor | None = ...,
        stop_time_update: collections.abc.Iterable[global___TripUpdate.StopTimeUpdate] | None = ...,
        timestamp: builtins.int | None = ...,
        delay: builtins.int | None = ...,
        trip_properties: global___TripUpdate.TripProperties | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["delay", b"delay", "timestamp", b"timestamp", "trip", b"trip", "trip_properties", b"trip_properties", "vehicle", b"vehicle"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["delay", b"delay", "stop_time_update", b"stop_time_update", "timestamp", b"timestamp", "trip", b"trip", "trip_properties", b"trip_properties", "vehicle", b"vehicle"]) -> None: ...

global___TripUpdate = TripUpdate

@typing_extensions.final
class VehiclePosition(google.protobuf.message.Message):
    """Realtime positioning information for a given vehicle."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _VehicleStopStatus:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _VehicleStopStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[VehiclePosition._VehicleStopStatus.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        INCOMING_AT: VehiclePosition._VehicleStopStatus.ValueType  # 0
        """The vehicle is just about to arrive at the stop (on a stop
        display, the vehicle symbol typically flashes).
        """
        STOPPED_AT: VehiclePosition._VehicleStopStatus.ValueType  # 1
        """The vehicle is standing at the stop."""
        IN_TRANSIT_TO: VehiclePosition._VehicleStopStatus.ValueType  # 2
        """The vehicle has departed and is in transit to the next stop."""

    class VehicleStopStatus(_VehicleStopStatus, metaclass=_VehicleStopStatusEnumTypeWrapper): ...
    INCOMING_AT: VehiclePosition.VehicleStopStatus.ValueType  # 0
    """The vehicle is just about to arrive at the stop (on a stop
    display, the vehicle symbol typically flashes).
    """
    STOPPED_AT: VehiclePosition.VehicleStopStatus.ValueType  # 1
    """The vehicle is standing at the stop."""
    IN_TRANSIT_TO: VehiclePosition.VehicleStopStatus.ValueType  # 2
    """The vehicle has departed and is in transit to the next stop."""

    class _CongestionLevel:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _CongestionLevelEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[VehiclePosition._CongestionLevel.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN_CONGESTION_LEVEL: VehiclePosition._CongestionLevel.ValueType  # 0
        RUNNING_SMOOTHLY: VehiclePosition._CongestionLevel.ValueType  # 1
        STOP_AND_GO: VehiclePosition._CongestionLevel.ValueType  # 2
        CONGESTION: VehiclePosition._CongestionLevel.ValueType  # 3
        SEVERE_CONGESTION: VehiclePosition._CongestionLevel.ValueType  # 4
        """People leaving their cars."""

    class CongestionLevel(_CongestionLevel, metaclass=_CongestionLevelEnumTypeWrapper):
        """Congestion level that is affecting this vehicle."""

    UNKNOWN_CONGESTION_LEVEL: VehiclePosition.CongestionLevel.ValueType  # 0
    RUNNING_SMOOTHLY: VehiclePosition.CongestionLevel.ValueType  # 1
    STOP_AND_GO: VehiclePosition.CongestionLevel.ValueType  # 2
    CONGESTION: VehiclePosition.CongestionLevel.ValueType  # 3
    SEVERE_CONGESTION: VehiclePosition.CongestionLevel.ValueType  # 4
    """People leaving their cars."""

    class _OccupancyStatus:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _OccupancyStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[VehiclePosition._OccupancyStatus.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        EMPTY: VehiclePosition._OccupancyStatus.ValueType  # 0
        """The vehicle or carriage is considered empty by most measures, and has few or no
        passengers onboard, but is still accepting passengers.
        """
        MANY_SEATS_AVAILABLE: VehiclePosition._OccupancyStatus.ValueType  # 1
        """The vehicle or carriage has a large number of seats available.
        The amount of free seats out of the total seats available to be
        considered large enough to fall into this category is determined at the
        discretion of the producer.
        """
        FEW_SEATS_AVAILABLE: VehiclePosition._OccupancyStatus.ValueType  # 2
        """The vehicle or carriage has a relatively small number of seats available.
        The amount of free seats out of the total seats available to be
        considered small enough to fall into this category is determined at the
        discretion of the feed producer.
        """
        STANDING_ROOM_ONLY: VehiclePosition._OccupancyStatus.ValueType  # 3
        """The vehicle or carriage can currently accommodate only standing passengers."""
        CRUSHED_STANDING_ROOM_ONLY: VehiclePosition._OccupancyStatus.ValueType  # 4
        """The vehicle or carriage can currently accommodate only standing passengers
        and has limited space for them.
        """
        FULL: VehiclePosition._OccupancyStatus.ValueType  # 5
        """The vehicle or carriage is considered full by most measures, but may still be
        allowing passengers to board.
        """
        NOT_ACCEPTING_PASSENGERS: VehiclePosition._OccupancyStatus.ValueType  # 6
        """The vehicle or carriage is not accepting passengers, but usually accepts passengers for boarding."""
        NO_DATA_AVAILABLE: VehiclePosition._OccupancyStatus.ValueType  # 7
        """The vehicle or carriage doesn't have any occupancy data available at that time."""
        NOT_BOARDABLE: VehiclePosition._OccupancyStatus.ValueType  # 8
        """The vehicle or carriage is not boardable and never accepts passengers.
        Useful for special vehicles or carriages (engine, maintenance carriage, etc…).
        """

    class OccupancyStatus(_OccupancyStatus, metaclass=_OccupancyStatusEnumTypeWrapper):
        """The state of passenger occupancy for the vehicle or carriage.
        Individual producers may not publish all OccupancyStatus values. Therefore, consumers
        must not assume that the OccupancyStatus values follow a linear scale.
        Consumers should represent OccupancyStatus values as the state indicated 
        and intended by the producer. Likewise, producers must use OccupancyStatus values that
        correspond to actual vehicle occupancy states.
        For describing passenger occupancy levels on a linear scale, see `occupancy_percentage`.
        This field is still experimental, and subject to change. It may be formally adopted in the future.
        """

    EMPTY: VehiclePosition.OccupancyStatus.ValueType  # 0
    """The vehicle or carriage is considered empty by most measures, and has few or no
    passengers onboard, but is still accepting passengers.
    """
    MANY_SEATS_AVAILABLE: VehiclePosition.OccupancyStatus.ValueType  # 1
    """The vehicle or carriage has a large number of seats available.
    The amount of free seats out of the total seats available to be
    considered large enough to fall into this category is determined at the
    discretion of the producer.
    """
    FEW_SEATS_AVAILABLE: VehiclePosition.OccupancyStatus.ValueType  # 2
    """The vehicle or carriage has a relatively small number of seats available.
    The amount of free seats out of the total seats available to be
    considered small enough to fall into this category is determined at the
    discretion of the feed producer.
    """
    STANDING_ROOM_ONLY: VehiclePosition.OccupancyStatus.ValueType  # 3
    """The vehicle or carriage can currently accommodate only standing passengers."""
    CRUSHED_STANDING_ROOM_ONLY: VehiclePosition.OccupancyStatus.ValueType  # 4
    """The vehicle or carriage can currently accommodate only standing passengers
    and has limited space for them.
    """
    FULL: VehiclePosition.OccupancyStatus.ValueType  # 5
    """The vehicle or carriage is considered full by most measures, but may still be
    allowing passengers to board.
    """
    NOT_ACCEPTING_PASSENGERS: VehiclePosition.OccupancyStatus.ValueType  # 6
    """The vehicle or carriage is not accepting passengers, but usually accepts passengers for boarding."""
    NO_DATA_AVAILABLE: VehiclePosition.OccupancyStatus.ValueType  # 7
    """The vehicle or carriage doesn't have any occupancy data available at that time."""
    NOT_BOARDABLE: VehiclePosition.OccupancyStatus.ValueType  # 8
    """The vehicle or carriage is not boardable and never accepts passengers.
    Useful for special vehicles or carriages (engine, maintenance carriage, etc…).
    """

    @typing_extensions.final
    class CarriageDetails(google.protobuf.message.Message):
        """Carriage specific details, used for vehicles composed of several carriages
        This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ID_FIELD_NUMBER: builtins.int
        LABEL_FIELD_NUMBER: builtins.int
        OCCUPANCY_STATUS_FIELD_NUMBER: builtins.int
        OCCUPANCY_PERCENTAGE_FIELD_NUMBER: builtins.int
        CARRIAGE_SEQUENCE_FIELD_NUMBER: builtins.int
        id: builtins.str
        """Identification of the carriage. Should be unique per vehicle."""
        label: builtins.str
        """User visible label that may be shown to the passenger to help identify
        the carriage. Example: "7712", "Car ABC-32", etc...
        This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        """
        occupancy_status: global___VehiclePosition.OccupancyStatus.ValueType
        """Occupancy status for this given carriage, in this vehicle
        This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        """
        occupancy_percentage: builtins.int
        """Occupancy percentage for this given carriage, in this vehicle.
        Follows the same rules as "VehiclePosition.occupancy_percentage"
        -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
        This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        """
        carriage_sequence: builtins.int
        """Identifies the order of this carriage with respect to the other
        carriages in the vehicle's list of CarriageDetails.
        The first carriage in the direction of travel must have a value of 1.
        The second value corresponds to the second carriage in the direction
        of travel and must have a value of 2, and so forth.
        For example, the first carriage in the direction of travel has a value of 1.
        If the second carriage in the direction of travel has a value of 3,
        consumers will discard data for all carriages (i.e., the multi_carriage_details field).
        Carriages without data must be represented with a valid carriage_sequence number and the fields 
        without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
        This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        """
        def __init__(
            self,
            *,
            id: builtins.str | None = ...,
            label: builtins.str | None = ...,
            occupancy_status: global___VehiclePosition.OccupancyStatus.ValueType | None = ...,
            occupancy_percentage: builtins.int | None = ...,
            carriage_sequence: builtins.int | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["carriage_sequence", b"carriage_sequence", "id", b"id", "label", b"label", "occupancy_percentage", b"occupancy_percentage", "occupancy_status", b"occupancy_status"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["carriage_sequence", b"carriage_sequence", "id", b"id", "label", b"label", "occupancy_percentage", b"occupancy_percentage", "occupancy_status", b"occupancy_status"]) -> None: ...

    TRIP_FIELD_NUMBER: builtins.int
    VEHICLE_FIELD_NUMBER: builtins.int
    POSITION_FIELD_NUMBER: builtins.int
    CURRENT_STOP_SEQUENCE_FIELD_NUMBER: builtins.int
    STOP_ID_FIELD_NUMBER: builtins.int
    CURRENT_STATUS_FIELD_NUMBER: builtins.int
    TIMESTAMP_FIELD_NUMBER: builtins.int
    CONGESTION_LEVEL_FIELD_NUMBER: builtins.int
    OCCUPANCY_STATUS_FIELD_NUMBER: builtins.int
    OCCUPANCY_PERCENTAGE_FIELD_NUMBER: builtins.int
    MULTI_CARRIAGE_DETAILS_FIELD_NUMBER: builtins.int
    @property
    def trip(self) -> global___TripDescriptor:
        """The Trip that this vehicle is serving.
        Can be empty or partial if the vehicle can not be identified with a given
        trip instance.
        """
    @property
    def vehicle(self) -> global___VehicleDescriptor:
        """Additional information on the vehicle that is serving this trip."""
    @property
    def position(self) -> global___Position:
        """Current position of this vehicle."""
    current_stop_sequence: builtins.int
    """The stop sequence index of the current stop. The meaning of
    current_stop_sequence (i.e., the stop that it refers to) is determined by
    current_status.
    If current_status is missing IN_TRANSIT_TO is assumed.
    """
    stop_id: builtins.str
    """Identifies the current stop. The value must be the same as in stops.txt in
    the corresponding GTFS feed.
    """
    current_status: global___VehiclePosition.VehicleStopStatus.ValueType
    """The exact status of the vehicle with respect to the current stop.
    Ignored if current_stop_sequence is missing.
    """
    timestamp: builtins.int
    """Moment at which the vehicle's position was measured. In POSIX time
    (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
    """
    congestion_level: global___VehiclePosition.CongestionLevel.ValueType
    occupancy_status: global___VehiclePosition.OccupancyStatus.ValueType
    """If multi_carriage_status is populated with per-carriage OccupancyStatus,
    then this field should describe the entire vehicle with all carriages accepting passengers considered.
    """
    occupancy_percentage: builtins.int
    """A percentage value indicating the degree of passenger occupancy in the vehicle.
    The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
    The value 100 should represent the total maximum occupancy the vehicle was designed for,
    including both seated and standing capacity, and current operating regulations allow.
    The value may exceed 100 if there are more passengers than the maximum designed capacity.
    The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
    If multi_carriage_status is populated with per-carriage occupancy_percentage, 
    then this field should describe the entire vehicle with all carriages accepting passengers considered.
    This field is still experimental, and subject to change. It may be formally adopted in the future.
    """
    @property
    def multi_carriage_details(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___VehiclePosition.CarriageDetails]:
        """Details of the multiple carriages of this given vehicle.
        The first occurrence represents the first carriage of the vehicle, 
        given the current direction of travel. 
        The number of occurrences of the multi_carriage_details 
        field represents the number of carriages of the vehicle.
        It also includes non boardable carriages, 
        like engines, maintenance carriages, etc… as they provide valuable 
        information to passengers about where to stand on a platform.
        This message/field is still experimental, and subject to change. It may be formally adopted in the future.
        """
    def __init__(
        self,
        *,
        trip: global___TripDescriptor | None = ...,
        vehicle: global___VehicleDescriptor | None = ...,
        position: global___Position | None = ...,
        current_stop_sequence: builtins.int | None = ...,
        stop_id: builtins.str | None = ...,
        current_status: global___VehiclePosition.VehicleStopStatus.ValueType | None = ...,
        timestamp: builtins.int | None = ...,
        congestion_level: global___VehiclePosition.CongestionLevel.ValueType | None = ...,
        occupancy_status: global___VehiclePosition.OccupancyStatus.ValueType | None = ...,
        occupancy_percentage: builtins.int | None = ...,
        multi_carriage_details: collections.abc.Iterable[global___VehiclePosition.CarriageDetails] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["congestion_level", b"congestion_level", "current_status", b"current_status", "current_stop_sequence", b"current_stop_sequence", "occupancy_percentage", b"occupancy_percentage", "occupancy_status", b"occupancy_status", "position", b"position", "stop_id", b"stop_id", "timestamp", b"timestamp", "trip", b"trip", "vehicle", b"vehicle"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["congestion_level", b"congestion_level", "current_status", b"current_status", "current_stop_sequence", b"current_stop_sequence", "multi_carriage_details", b"multi_carriage_details", "occupancy_percentage", b"occupancy_percentage", "occupancy_status", b"occupancy_status", "position", b"position", "stop_id", b"stop_id", "timestamp", b"timestamp", "trip", b"trip", "vehicle", b"vehicle"]) -> None: ...

global___VehiclePosition = VehiclePosition

@typing_extensions.final
class Alert(google.protobuf.message.Message):
    """An alert, indicating some sort of incident in the public transit network."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Cause:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _CauseEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Alert._Cause.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN_CAUSE: Alert._Cause.ValueType  # 1
        OTHER_CAUSE: Alert._Cause.ValueType  # 2
        """Not machine-representable."""
        TECHNICAL_PROBLEM: Alert._Cause.ValueType  # 3
        STRIKE: Alert._Cause.ValueType  # 4
        """Public transit agency employees stopped working."""
        DEMONSTRATION: Alert._Cause.ValueType  # 5
        """People are blocking the streets."""
        ACCIDENT: Alert._Cause.ValueType  # 6
        HOLIDAY: Alert._Cause.ValueType  # 7
        WEATHER: Alert._Cause.ValueType  # 8
        MAINTENANCE: Alert._Cause.ValueType  # 9
        CONSTRUCTION: Alert._Cause.ValueType  # 10
        POLICE_ACTIVITY: Alert._Cause.ValueType  # 11
        MEDICAL_EMERGENCY: Alert._Cause.ValueType  # 12

    class Cause(_Cause, metaclass=_CauseEnumTypeWrapper):
        """Cause of this alert. If cause_detail is included, then Cause must also be included."""

    UNKNOWN_CAUSE: Alert.Cause.ValueType  # 1
    OTHER_CAUSE: Alert.Cause.ValueType  # 2
    """Not machine-representable."""
    TECHNICAL_PROBLEM: Alert.Cause.ValueType  # 3
    STRIKE: Alert.Cause.ValueType  # 4
    """Public transit agency employees stopped working."""
    DEMONSTRATION: Alert.Cause.ValueType  # 5
    """People are blocking the streets."""
    ACCIDENT: Alert.Cause.ValueType  # 6
    HOLIDAY: Alert.Cause.ValueType  # 7
    WEATHER: Alert.Cause.ValueType  # 8
    MAINTENANCE: Alert.Cause.ValueType  # 9
    CONSTRUCTION: Alert.Cause.ValueType  # 10
    POLICE_ACTIVITY: Alert.Cause.ValueType  # 11
    MEDICAL_EMERGENCY: Alert.Cause.ValueType  # 12

    class _Effect:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _EffectEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Alert._Effect.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        NO_SERVICE: Alert._Effect.ValueType  # 1
        REDUCED_SERVICE: Alert._Effect.ValueType  # 2
        SIGNIFICANT_DELAYS: Alert._Effect.ValueType  # 3
        """We don't care about INsignificant delays: they are hard to detect, have
        little impact on the user, and would clutter the results as they are too
        frequent.
        """
        DETOUR: Alert._Effect.ValueType  # 4
        ADDITIONAL_SERVICE: Alert._Effect.ValueType  # 5
        MODIFIED_SERVICE: Alert._Effect.ValueType  # 6
        OTHER_EFFECT: Alert._Effect.ValueType  # 7
        UNKNOWN_EFFECT: Alert._Effect.ValueType  # 8
        STOP_MOVED: Alert._Effect.ValueType  # 9
        NO_EFFECT: Alert._Effect.ValueType  # 10
        ACCESSIBILITY_ISSUE: Alert._Effect.ValueType  # 11

    class Effect(_Effect, metaclass=_EffectEnumTypeWrapper):
        """What is the effect of this problem on the affected entity. If effect_detail is included, then Effect must also be included."""

    NO_SERVICE: Alert.Effect.ValueType  # 1
    REDUCED_SERVICE: Alert.Effect.ValueType  # 2
    SIGNIFICANT_DELAYS: Alert.Effect.ValueType  # 3
    """We don't care about INsignificant delays: they are hard to detect, have
    little impact on the user, and would clutter the results as they are too
    frequent.
    """
    DETOUR: Alert.Effect.ValueType  # 4
    ADDITIONAL_SERVICE: Alert.Effect.ValueType  # 5
    MODIFIED_SERVICE: Alert.Effect.ValueType  # 6
    OTHER_EFFECT: Alert.Effect.ValueType  # 7
    UNKNOWN_EFFECT: Alert.Effect.ValueType  # 8
    STOP_MOVED: Alert.Effect.ValueType  # 9
    NO_EFFECT: Alert.Effect.ValueType  # 10
    ACCESSIBILITY_ISSUE: Alert.Effect.ValueType  # 11

    class _SeverityLevel:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _SeverityLevelEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Alert._SeverityLevel.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN_SEVERITY: Alert._SeverityLevel.ValueType  # 1
        INFO: Alert._SeverityLevel.ValueType  # 2
        WARNING: Alert._SeverityLevel.ValueType  # 3
        SEVERE: Alert._SeverityLevel.ValueType  # 4

    class SeverityLevel(_SeverityLevel, metaclass=_SeverityLevelEnumTypeWrapper):
        """Severity of this alert."""

    UNKNOWN_SEVERITY: Alert.SeverityLevel.ValueType  # 1
    INFO: Alert.SeverityLevel.ValueType  # 2
    WARNING: Alert.SeverityLevel.ValueType  # 3
    SEVERE: Alert.SeverityLevel.ValueType  # 4

    ACTIVE_PERIOD_FIELD_NUMBER: builtins.int
    INFORMED_ENTITY_FIELD_NUMBER: builtins.int
    CAUSE_FIELD_NUMBER: builtins.int
    EFFECT_FIELD_NUMBER: builtins.int
    URL_FIELD_NUMBER: builtins.int
    HEADER_TEXT_FIELD_NUMBER: builtins.int
    DESCRIPTION_TEXT_FIELD_NUMBER: builtins.int
    TTS_HEADER_TEXT_FIELD_NUMBER: builtins.int
    TTS_DESCRIPTION_TEXT_FIELD_NUMBER: builtins.int
    SEVERITY_LEVEL_FIELD_NUMBER: builtins.int
    IMAGE_FIELD_NUMBER: builtins.int
    IMAGE_ALTERNATIVE_TEXT_FIELD_NUMBER: builtins.int
    CAUSE_DETAIL_FIELD_NUMBER: builtins.int
    EFFECT_DETAIL_FIELD_NUMBER: builtins.int
    @property
    def active_period(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TimeRange]:
        """Time when the alert should be shown to the user. If missing, the
        alert will be shown as long as it appears in the feed.
        If multiple ranges are given, the alert will be shown during all of them.
        """
    @property
    def informed_entity(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___EntitySelector]:
        """Entities whose users we should notify of this alert."""
    cause: global___Alert.Cause.ValueType
    effect: global___Alert.Effect.ValueType
    @property
    def url(self) -> global___TranslatedString:
        """The URL which provides additional information about the alert."""
    @property
    def header_text(self) -> global___TranslatedString:
        """Alert header. Contains a short summary of the alert text as plain-text."""
    @property
    def description_text(self) -> global___TranslatedString:
        """Full description for the alert as plain-text. The information in the
        description should add to the information of the header.
        """
    @property
    def tts_header_text(self) -> global___TranslatedString:
        """Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text."""
    @property
    def tts_description_text(self) -> global___TranslatedString:
        """Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text."""
    severity_level: global___Alert.SeverityLevel.ValueType
    @property
    def image(self) -> global___TranslatedImage:
        """TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
        The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
        NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        """
    @property
    def image_alternative_text(self) -> global___TranslatedString:
        """Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
        or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
        NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        """
    @property
    def cause_detail(self) -> global___TranslatedString:
        """Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
        NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        """
    @property
    def effect_detail(self) -> global___TranslatedString:
        """Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
        NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        """
    def __init__(
        self,
        *,
        active_period: collections.abc.Iterable[global___TimeRange] | None = ...,
        informed_entity: collections.abc.Iterable[global___EntitySelector] | None = ...,
        cause: global___Alert.Cause.ValueType | None = ...,
        effect: global___Alert.Effect.ValueType | None = ...,
        url: global___TranslatedString | None = ...,
        header_text: global___TranslatedString | None = ...,
        description_text: global___TranslatedString | None = ...,
        tts_header_text: global___TranslatedString | None = ...,
        tts_description_text: global___TranslatedString | None = ...,
        severity_level: global___Alert.SeverityLevel.ValueType | None = ...,
        image: global___TranslatedImage | None = ...,
        image_alternative_text: global___TranslatedString | None = ...,
        cause_detail: global___TranslatedString | None = ...,
        effect_detail: global___TranslatedString | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["cause", b"cause", "cause_detail", b"cause_detail", "description_text", b"description_text", "effect", b"effect", "effect_detail", b"effect_detail", "header_text", b"header_text", "image", b"image", "image_alternative_text", b"image_alternative_text", "severity_level", b"severity_level", "tts_description_text", b"tts_description_text", "tts_header_text", b"tts_header_text", "url", b"url"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["active_period", b"active_period", "cause", b"cause", "cause_detail", b"cause_detail", "description_text", b"description_text", "effect", b"effect", "effect_detail", b"effect_detail", "header_text", b"header_text", "image", b"image", "image_alternative_text", b"image_alternative_text", "informed_entity", b"informed_entity", "severity_level", b"severity_level", "tts_description_text", b"tts_description_text", "tts_header_text", b"tts_header_text", "url", b"url"]) -> None: ...

global___Alert = Alert

@typing_extensions.final
class TimeRange(google.protobuf.message.Message):
    """
    Low level data structures used above.

    A time interval. The interval is considered active at time 't' if 't' is
    greater than or equal to the start time and less than the end time.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    START_FIELD_NUMBER: builtins.int
    END_FIELD_NUMBER: builtins.int
    start: builtins.int
    """Start time, in POSIX time (i.e., number of seconds since January 1st 1970
    00:00:00 UTC).
    If missing, the interval starts at minus infinity.
    """
    end: builtins.int
    """End time, in POSIX time (i.e., number of seconds since January 1st 1970
    00:00:00 UTC).
    If missing, the interval ends at plus infinity.
    """
    def __init__(
        self,
        *,
        start: builtins.int | None = ...,
        end: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end", b"end", "start", b"start"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["end", b"end", "start", b"start"]) -> None: ...

global___TimeRange = TimeRange

@typing_extensions.final
class Position(google.protobuf.message.Message):
    """A position."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    LATITUDE_FIELD_NUMBER: builtins.int
    LONGITUDE_FIELD_NUMBER: builtins.int
    BEARING_FIELD_NUMBER: builtins.int
    ODOMETER_FIELD_NUMBER: builtins.int
    SPEED_FIELD_NUMBER: builtins.int
    latitude: builtins.float
    """Degrees North, in the WGS-84 coordinate system."""
    longitude: builtins.float
    """Degrees East, in the WGS-84 coordinate system."""
    bearing: builtins.float
    """Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
    This can be the compass bearing, or the direction towards the next stop
    or intermediate location.
    This should not be direction deduced from the sequence of previous
    positions, which can be computed from previous data.
    """
    odometer: builtins.float
    """Odometer value, in meters."""
    speed: builtins.float
    """Momentary speed measured by the vehicle, in meters per second."""
    def __init__(
        self,
        *,
        latitude: builtins.float | None = ...,
        longitude: builtins.float | None = ...,
        bearing: builtins.float | None = ...,
        odometer: builtins.float | None = ...,
        speed: builtins.float | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["bearing", b"bearing", "latitude", b"latitude", "longitude", b"longitude", "odometer", b"odometer", "speed", b"speed"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["bearing", b"bearing", "latitude", b"latitude", "longitude", b"longitude", "odometer", b"odometer", "speed", b"speed"]) -> None: ...

global___Position = Position

@typing_extensions.final
class TripDescriptor(google.protobuf.message.Message):
    """A descriptor that identifies an instance of a GTFS trip, or all instances of
    a trip along a route.
    - To specify a single trip instance, the trip_id (and if necessary,
      start_time) is set. If route_id is also set, then it should be same as one
      that the given trip corresponds to.
    - To specify all the trips along a given route, only the route_id should be
      set. Note that if the trip_id is not known, then stop sequence ids in
      TripUpdate are not sufficient, and stop_ids must be provided as well. In
      addition, absolute arrival/departure times must be provided.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _ScheduleRelationship:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _ScheduleRelationshipEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[TripDescriptor._ScheduleRelationship.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        SCHEDULED: TripDescriptor._ScheduleRelationship.ValueType  # 0
        """Trip that is running in accordance with its GTFS schedule, or is close
        enough to the scheduled trip to be associated with it.
        """
        ADDED: TripDescriptor._ScheduleRelationship.ValueType  # 1
        """An extra trip that was added in addition to a running schedule, for
        example, to replace a broken vehicle or to respond to sudden passenger
        load.
        NOTE: Currently, behavior is unspecified for feeds that use this mode. There are discussions on the GTFS GitHub
        [(1)](https://github.com/google/transit/issues/106) [(2)](https://github.com/google/transit/pull/221)
        [(3)](https://github.com/google/transit/pull/219) around fully specifying or deprecating ADDED trips and the
        documentation will be updated when those discussions are finalized.
        """
        UNSCHEDULED: TripDescriptor._ScheduleRelationship.ValueType  # 2
        """A trip that is running with no schedule associated to it (GTFS frequencies.txt exact_times=0).
        Trips with ScheduleRelationship=UNSCHEDULED must also set all StopTimeUpdates.ScheduleRelationship=UNSCHEDULED.
        """
        CANCELED: TripDescriptor._ScheduleRelationship.ValueType  # 3
        """A trip that existed in the schedule but was removed."""
        REPLACEMENT: TripDescriptor._ScheduleRelationship.ValueType  # 5
        """Should not be used - for backwards-compatibility only."""
        DUPLICATED: TripDescriptor._ScheduleRelationship.ValueType  # 6
        """An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to
        respond to sudden passenger load. Used with TripUpdate.TripProperties.trip_id, TripUpdate.TripProperties.start_date,
        and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service
        date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS
        (in calendar.txt or calendar_dates.txt) is operating within the next 30 days. The trip to be duplicated is
        identified via TripUpdate.TripDescriptor.trip_id. This enumeration does not modify the existing trip referenced by
        TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate
        TripUpdate with the value of CANCELED or DELETED. Trips defined in GTFS frequencies.txt with exact_times that is
        empty or equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain
        the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship
        must also be set to DUPLICATED.
        Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow
        the migration guide (https://github.com/google/transit/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md)
        to transition to the DUPLICATED enumeration.
        NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        """
        DELETED: TripDescriptor._ScheduleRelationship.ValueType  # 7
        """A trip that existed in the schedule but was removed and must not be shown to users.
        DELETED should be used instead of CANCELED to indicate that a transit provider would like to entirely remove
        information about the corresponding trip from consuming applications, so the trip is not shown as cancelled to
        riders, e.g. a trip that is entirely being replaced by another trip.
        This designation becomes particularly important if several trips are cancelled and replaced with substitute service.
        If consumers were to show explicit information about the cancellations it would distract from the more important
        real-time predictions.
        NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
        """

    class ScheduleRelationship(_ScheduleRelationship, metaclass=_ScheduleRelationshipEnumTypeWrapper):
        """The relation between this trip and the static schedule. If a trip is done
        in accordance with temporary schedule, not reflected in GTFS, then it
        shouldn't be marked as SCHEDULED, but likely as ADDED.
        """

    SCHEDULED: TripDescriptor.ScheduleRelationship.ValueType  # 0
    """Trip that is running in accordance with its GTFS schedule, or is close
    enough to the scheduled trip to be associated with it.
    """
    ADDED: TripDescriptor.ScheduleRelationship.ValueType  # 1
    """An extra trip that was added in addition to a running schedule, for
    example, to replace a broken vehicle or to respond to sudden passenger
    load.
    NOTE: Currently, behavior is unspecified for feeds that use this mode. There are discussions on the GTFS GitHub
    [(1)](https://github.com/google/transit/issues/106) [(2)](https://github.com/google/transit/pull/221)
    [(3)](https://github.com/google/transit/pull/219) around fully specifying or deprecating ADDED trips and the
    documentation will be updated when those discussions are finalized.
    """
    UNSCHEDULED: TripDescriptor.ScheduleRelationship.ValueType  # 2
    """A trip that is running with no schedule associated to it (GTFS frequencies.txt exact_times=0).
    Trips with ScheduleRelationship=UNSCHEDULED must also set all StopTimeUpdates.ScheduleRelationship=UNSCHEDULED.
    """
    CANCELED: TripDescriptor.ScheduleRelationship.ValueType  # 3
    """A trip that existed in the schedule but was removed."""
    REPLACEMENT: TripDescriptor.ScheduleRelationship.ValueType  # 5
    """Should not be used - for backwards-compatibility only."""
    DUPLICATED: TripDescriptor.ScheduleRelationship.ValueType  # 6
    """An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to
    respond to sudden passenger load. Used with TripUpdate.TripProperties.trip_id, TripUpdate.TripProperties.start_date,
    and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service
    date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS
    (in calendar.txt or calendar_dates.txt) is operating within the next 30 days. The trip to be duplicated is
    identified via TripUpdate.TripDescriptor.trip_id. This enumeration does not modify the existing trip referenced by
    TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate
    TripUpdate with the value of CANCELED or DELETED. Trips defined in GTFS frequencies.txt with exact_times that is
    empty or equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain
    the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship
    must also be set to DUPLICATED.
    Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow
    the migration guide (https://github.com/google/transit/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md)
    to transition to the DUPLICATED enumeration.
    NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    """
    DELETED: TripDescriptor.ScheduleRelationship.ValueType  # 7
    """A trip that existed in the schedule but was removed and must not be shown to users.
    DELETED should be used instead of CANCELED to indicate that a transit provider would like to entirely remove
    information about the corresponding trip from consuming applications, so the trip is not shown as cancelled to
    riders, e.g. a trip that is entirely being replaced by another trip.
    This designation becomes particularly important if several trips are cancelled and replaced with substitute service.
    If consumers were to show explicit information about the cancellations it would distract from the more important
    real-time predictions.
    NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    """

    TRIP_ID_FIELD_NUMBER: builtins.int
    ROUTE_ID_FIELD_NUMBER: builtins.int
    DIRECTION_ID_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    START_DATE_FIELD_NUMBER: builtins.int
    SCHEDULE_RELATIONSHIP_FIELD_NUMBER: builtins.int
    trip_id: builtins.str
    """The trip_id from the GTFS feed that this selector refers to.
    For non frequency-based trips, this field is enough to uniquely identify
    the trip. For frequency-based trip, start_time and start_date might also be
    necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
    static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
    identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
    """
    route_id: builtins.str
    """The route_id from the GTFS that this selector refers to."""
    direction_id: builtins.int
    """The direction_id from the GTFS feed trips.txt file, indicating the
    direction of travel for trips this selector refers to.
    """
    start_time: builtins.str
    """The initially scheduled start time of this trip instance.
    When the trip_id corresponds to a non-frequency-based trip, this field
    should either be omitted or be equal to the value in the GTFS feed. When
    the trip_id correponds to a frequency-based trip, the start_time must be
    specified for trip updates and vehicle positions. If the trip corresponds
    to exact_times=1 GTFS record, then start_time must be some multiple
    (including zero) of headway_secs later than frequencies.txt start_time for
    the corresponding time period. If the trip corresponds to exact_times=0,
    then its start_time may be arbitrary, and is initially expected to be the
    first departure of the trip. Once established, the start_time of this
    frequency-based trip should be considered immutable, even if the first
    departure time changes -- that time change may instead be reflected in a
    StopTimeUpdate.
    Format and semantics of the field is same as that of
    GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
    """
    start_date: builtins.str
    """The scheduled start date of this trip instance.
    Must be provided to disambiguate trips that are so late as to collide with
    a scheduled trip on a next day. For example, for a train that departs 8:00
    and 20:00 every day, and is 12 hours late, there would be two distinct
    trips on the same time.
    This field can be provided but is not mandatory for schedules in which such
    collisions are impossible - for example, a service running on hourly
    schedule where a vehicle that is one hour late is not considered to be
    related to schedule anymore.
    In YYYYMMDD format.
    """
    schedule_relationship: global___TripDescriptor.ScheduleRelationship.ValueType
    def __init__(
        self,
        *,
        trip_id: builtins.str | None = ...,
        route_id: builtins.str | None = ...,
        direction_id: builtins.int | None = ...,
        start_time: builtins.str | None = ...,
        start_date: builtins.str | None = ...,
        schedule_relationship: global___TripDescriptor.ScheduleRelationship.ValueType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["direction_id", b"direction_id", "route_id", b"route_id", "schedule_relationship", b"schedule_relationship", "start_date", b"start_date", "start_time", b"start_time", "trip_id", b"trip_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["direction_id", b"direction_id", "route_id", b"route_id", "schedule_relationship", b"schedule_relationship", "start_date", b"start_date", "start_time", b"start_time", "trip_id", b"trip_id"]) -> None: ...

global___TripDescriptor = TripDescriptor

@typing_extensions.final
class VehicleDescriptor(google.protobuf.message.Message):
    """Identification information for the vehicle performing the trip."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _WheelchairAccessible:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _WheelchairAccessibleEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[VehicleDescriptor._WheelchairAccessible.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        NO_VALUE: VehicleDescriptor._WheelchairAccessible.ValueType  # 0
        """The trip doesn't have information about wheelchair accessibility.
        This is the **default** behavior. If the static GTFS contains a
        _wheelchair_accessible_ value, it won't be overwritten.
        """
        UNKNOWN: VehicleDescriptor._WheelchairAccessible.ValueType  # 1
        """The trip has no accessibility value present.
        This value will overwrite the value from the GTFS.
        """
        WHEELCHAIR_ACCESSIBLE: VehicleDescriptor._WheelchairAccessible.ValueType  # 2
        """The trip is wheelchair accessible.
        This value will overwrite the value from the GTFS.
        """
        WHEELCHAIR_INACCESSIBLE: VehicleDescriptor._WheelchairAccessible.ValueType  # 3
        """The trip is **not** wheelchair accessible.
        This value will overwrite the value from the GTFS.
        """

    class WheelchairAccessible(_WheelchairAccessible, metaclass=_WheelchairAccessibleEnumTypeWrapper): ...
    NO_VALUE: VehicleDescriptor.WheelchairAccessible.ValueType  # 0
    """The trip doesn't have information about wheelchair accessibility.
    This is the **default** behavior. If the static GTFS contains a
    _wheelchair_accessible_ value, it won't be overwritten.
    """
    UNKNOWN: VehicleDescriptor.WheelchairAccessible.ValueType  # 1
    """The trip has no accessibility value present.
    This value will overwrite the value from the GTFS.
    """
    WHEELCHAIR_ACCESSIBLE: VehicleDescriptor.WheelchairAccessible.ValueType  # 2
    """The trip is wheelchair accessible.
    This value will overwrite the value from the GTFS.
    """
    WHEELCHAIR_INACCESSIBLE: VehicleDescriptor.WheelchairAccessible.ValueType  # 3
    """The trip is **not** wheelchair accessible.
    This value will overwrite the value from the GTFS.
    """

    ID_FIELD_NUMBER: builtins.int
    LABEL_FIELD_NUMBER: builtins.int
    LICENSE_PLATE_FIELD_NUMBER: builtins.int
    WHEELCHAIR_ACCESSIBLE_FIELD_NUMBER: builtins.int
    id: builtins.str
    """Internal system identification of the vehicle. Should be unique per
    vehicle, and can be used for tracking the vehicle as it proceeds through
    the system.
    """
    label: builtins.str
    """User visible label, i.e., something that must be shown to the passenger to
    help identify the correct vehicle.
    """
    license_plate: builtins.str
    """The license plate of the vehicle."""
    wheelchair_accessible: global___VehicleDescriptor.WheelchairAccessible.ValueType
    def __init__(
        self,
        *,
        id: builtins.str | None = ...,
        label: builtins.str | None = ...,
        license_plate: builtins.str | None = ...,
        wheelchair_accessible: global___VehicleDescriptor.WheelchairAccessible.ValueType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["id", b"id", "label", b"label", "license_plate", b"license_plate", "wheelchair_accessible", b"wheelchair_accessible"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["id", b"id", "label", b"label", "license_plate", b"license_plate", "wheelchair_accessible", b"wheelchair_accessible"]) -> None: ...

global___VehicleDescriptor = VehicleDescriptor

@typing_extensions.final
class EntitySelector(google.protobuf.message.Message):
    """A selector for an entity in a GTFS feed."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AGENCY_ID_FIELD_NUMBER: builtins.int
    ROUTE_ID_FIELD_NUMBER: builtins.int
    ROUTE_TYPE_FIELD_NUMBER: builtins.int
    TRIP_FIELD_NUMBER: builtins.int
    STOP_ID_FIELD_NUMBER: builtins.int
    DIRECTION_ID_FIELD_NUMBER: builtins.int
    agency_id: builtins.str
    """The values of the fields should correspond to the appropriate fields in the
    GTFS feed.
    At least one specifier must be given. If several are given, then the
    matching has to apply to all the given specifiers.
    """
    route_id: builtins.str
    route_type: builtins.int
    """corresponds to route_type in GTFS."""
    @property
    def trip(self) -> global___TripDescriptor: ...
    stop_id: builtins.str
    direction_id: builtins.int
    """Corresponds to trip direction_id in GTFS trips.txt. If provided the
    route_id must also be provided.
    """
    def __init__(
        self,
        *,
        agency_id: builtins.str | None = ...,
        route_id: builtins.str | None = ...,
        route_type: builtins.int | None = ...,
        trip: global___TripDescriptor | None = ...,
        stop_id: builtins.str | None = ...,
        direction_id: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["agency_id", b"agency_id", "direction_id", b"direction_id", "route_id", b"route_id", "route_type", b"route_type", "stop_id", b"stop_id", "trip", b"trip"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["agency_id", b"agency_id", "direction_id", b"direction_id", "route_id", b"route_id", "route_type", b"route_type", "stop_id", b"stop_id", "trip", b"trip"]) -> None: ...

global___EntitySelector = EntitySelector

@typing_extensions.final
class TranslatedString(google.protobuf.message.Message):
    """An internationalized message containing per-language versions of a snippet of
    text or a URL.
    One of the strings from a message will be picked up. The resolution proceeds
    as follows:
    1. If the UI language matches the language code of a translation,
       the first matching translation is picked.
    2. If a default UI language (e.g., English) matches the language code of a
       translation, the first matching translation is picked.
    3. If some translation has an unspecified language code, that translation is
       picked.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class Translation(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TEXT_FIELD_NUMBER: builtins.int
        LANGUAGE_FIELD_NUMBER: builtins.int
        text: builtins.str
        """A UTF-8 string containing the message."""
        language: builtins.str
        """BCP-47 language code. Can be omitted if the language is unknown or if
        no i18n is done at all for the feed. At most one translation is
        allowed to have an unspecified language tag.
        """
        def __init__(
            self,
            *,
            text: builtins.str | None = ...,
            language: builtins.str | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["language", b"language", "text", b"text"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["language", b"language", "text", b"text"]) -> None: ...

    TRANSLATION_FIELD_NUMBER: builtins.int
    @property
    def translation(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TranslatedString.Translation]:
        """At least one translation must be provided."""
    def __init__(
        self,
        *,
        translation: collections.abc.Iterable[global___TranslatedString.Translation] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["translation", b"translation"]) -> None: ...

global___TranslatedString = TranslatedString

@typing_extensions.final
class TranslatedImage(google.protobuf.message.Message):
    """An internationalized image containing per-language versions of a URL linking to an image
    along with meta information
    Only one of the images from a message will be retained by consumers. The resolution proceeds
    as follows:
    1. If the UI language matches the language code of a translation,
       the first matching translation is picked.
    2. If a default UI language (e.g., English) matches the language code of a
       translation, the first matching translation is picked.
    3. If some translation has an unspecified language code, that translation is
       picked.
    NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class LocalizedImage(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        URL_FIELD_NUMBER: builtins.int
        MEDIA_TYPE_FIELD_NUMBER: builtins.int
        LANGUAGE_FIELD_NUMBER: builtins.int
        url: builtins.str
        """String containing an URL linking to an image
        The image linked must be less than 2MB. 
        If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
        The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
        """
        media_type: builtins.str
        """IANA media type as to specify the type of image to be displayed. 
        The type must start with "image/"
        """
        language: builtins.str
        """BCP-47 language code. Can be omitted if the language is unknown or if
        no i18n is done at all for the feed. At most one translation is
        allowed to have an unspecified language tag.
        """
        def __init__(
            self,
            *,
            url: builtins.str | None = ...,
            media_type: builtins.str | None = ...,
            language: builtins.str | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["language", b"language", "media_type", b"media_type", "url", b"url"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["language", b"language", "media_type", b"media_type", "url", b"url"]) -> None: ...

    LOCALIZED_IMAGE_FIELD_NUMBER: builtins.int
    @property
    def localized_image(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TranslatedImage.LocalizedImage]:
        """At least one localized image must be provided."""
    def __init__(
        self,
        *,
        localized_image: collections.abc.Iterable[global___TranslatedImage.LocalizedImage] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["localized_image", b"localized_image"]) -> None: ...

global___TranslatedImage = TranslatedImage

@typing_extensions.final
class Shape(google.protobuf.message.Message):
    """Describes the physical path that a vehicle takes when it's not part of the (CSV) GTFS,
    such as for a detour. Shapes belong to Trips, and consist of a sequence of shape points.
    Tracing the points in order provides the path of the vehicle.  Shapes do not need to intercept
    the location of Stops exactly, but all Stops on a trip should lie within a small distance of
    the shape for that trip, i.e. close to straight line segments connecting the shape points
    NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SHAPE_ID_FIELD_NUMBER: builtins.int
    ENCODED_POLYLINE_FIELD_NUMBER: builtins.int
    shape_id: builtins.str
    """Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
    This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
    See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
    NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    """
    encoded_polyline: builtins.str
    """Encoded polyline representation of the shape. This polyline must contain at least two points.
    For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
    This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
    See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
    NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    """
    def __init__(
        self,
        *,
        shape_id: builtins.str | None = ...,
        encoded_polyline: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["encoded_polyline", b"encoded_polyline", "shape_id", b"shape_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["encoded_polyline", b"encoded_polyline", "shape_id", b"shape_id"]) -> None: ...

global___Shape = Shape
